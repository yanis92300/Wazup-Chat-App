{"ast":null,"code":"/**\n * @typedef {Object} FormatSmartOptions\n * @property {boolean} [useNamedReferences=false] Prefer named character references (`&amp;`) where possible (`boolean?`, default: `false`)\n * @property {boolean} [useShortestReferences=false] Prefer the shortest possible reference, if that results in less bytes (`boolean?`, default: `false`). **Note**: `useNamedReferences` can be omitted when using `useShortestReferences`\n * @property {boolean} [omitOptionalSemicolons=false] Whether to omit semicolons when possible (`boolean?`, default: `false`). **Note**: This creates what HTML calls “parse errors” but is otherwise still valid HTML — don’t use this except when building a minifier. Omitting semicolons is possible for legacy named references in certain cases, and numeric references in some cases\n * @property {boolean} [attribute=false] Only needed when operating dangerously with `omitOptionalSemicolons: true`. Create character references which don’t fail in attributes (`boolean?`, default: `false`).\n */\nimport { toHexadecimal } from './to-hexadecimal.js';\nimport { toDecimal } from './to-decimal.js';\nimport { toNamed } from './to-named.js';\n/**\n * Encode `character` according to `options`.\n *\n * @param {number} code\n * @param {number} next\n * @param {FormatSmartOptions} options\n * @returns {string}\n */\n\nexport function formatSmart(code, next, options) {\n  /** @type {string} */\n  var named;\n  /** @type {string} */\n\n  var numeric;\n  /** @type {string} */\n\n  var decimal;\n\n  if (options.useNamedReferences || options.useShortestReferences) {\n    named = toNamed(code, next, options.omitOptionalSemicolons, options.attribute);\n  }\n\n  if (options.useShortestReferences || !named) {\n    numeric = toHexadecimal(code, next, options.omitOptionalSemicolons); // Use the shortest numeric reference when requested.\n    // A simple algorithm would use decimal for all code points under 100, as\n    // those are shorter than hexadecimal:\n    //\n    // * `&#99;` vs `&#x63;` (decimal shorter)\n    // * `&#100;` vs `&#x64;` (equal)\n    //\n    // However, because we take `next` into consideration when `omit` is used,\n    // And it would be possible that decimals are shorter on bigger values as\n    // well if `next` is hexadecimal but not decimal, we instead compare both.\n\n    if (options.useShortestReferences) {\n      decimal = toDecimal(code, next, options.omitOptionalSemicolons);\n\n      if (decimal.length < numeric.length) {\n        numeric = decimal;\n      }\n    }\n  }\n\n  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;\n}","map":{"version":3,"sources":["/home/chamson/Bureau/yanis_nicolas_webtech/05.mui/lab/front-end/node_modules/stringify-entities/lib/util/format-smart.js"],"names":["toHexadecimal","toDecimal","toNamed","formatSmart","code","next","options","named","numeric","decimal","useNamedReferences","useShortestReferences","omitOptionalSemicolons","attribute","length"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,aAAR,QAA4B,qBAA5B;AACA,SAAQC,SAAR,QAAwB,iBAAxB;AACA,SAAQC,OAAR,QAAsB,eAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,IAA3B,EAAiCC,OAAjC,EAA0C;AAC/C;AACA,MAAIC,KAAJ;AACA;;AACA,MAAIC,OAAJ;AACA;;AACA,MAAIC,OAAJ;;AAEA,MAAIH,OAAO,CAACI,kBAAR,IAA8BJ,OAAO,CAACK,qBAA1C,EAAiE;AAC/DJ,IAAAA,KAAK,GAAGL,OAAO,CACbE,IADa,EAEbC,IAFa,EAGbC,OAAO,CAACM,sBAHK,EAIbN,OAAO,CAACO,SAJK,CAAf;AAMD;;AAED,MAAIP,OAAO,CAACK,qBAAR,IAAiC,CAACJ,KAAtC,EAA6C;AAC3CC,IAAAA,OAAO,GAAGR,aAAa,CAACI,IAAD,EAAOC,IAAP,EAAaC,OAAO,CAACM,sBAArB,CAAvB,CAD2C,CAG3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAIN,OAAO,CAACK,qBAAZ,EAAmC;AACjCF,MAAAA,OAAO,GAAGR,SAAS,CAACG,IAAD,EAAOC,IAAP,EAAaC,OAAO,CAACM,sBAArB,CAAnB;;AAEA,UAAIH,OAAO,CAACK,MAAR,GAAiBN,OAAO,CAACM,MAA7B,EAAqC;AACnCN,QAAAA,OAAO,GAAGC,OAAV;AACD;AACF;AACF;;AAED,SAAOF,KAAK,KACT,CAACD,OAAO,CAACK,qBAAT,IAAkCJ,KAAK,CAACO,MAAN,GAAeN,OAAO,CAACM,MADhD,CAAL,GAEHP,KAFG,GAGHC,OAHJ;AAID","sourcesContent":["/**\n * @typedef {Object} FormatSmartOptions\n * @property {boolean} [useNamedReferences=false] Prefer named character references (`&amp;`) where possible (`boolean?`, default: `false`)\n * @property {boolean} [useShortestReferences=false] Prefer the shortest possible reference, if that results in less bytes (`boolean?`, default: `false`). **Note**: `useNamedReferences` can be omitted when using `useShortestReferences`\n * @property {boolean} [omitOptionalSemicolons=false] Whether to omit semicolons when possible (`boolean?`, default: `false`). **Note**: This creates what HTML calls “parse errors” but is otherwise still valid HTML — don’t use this except when building a minifier. Omitting semicolons is possible for legacy named references in certain cases, and numeric references in some cases\n * @property {boolean} [attribute=false] Only needed when operating dangerously with `omitOptionalSemicolons: true`. Create character references which don’t fail in attributes (`boolean?`, default: `false`).\n */\n\nimport {toHexadecimal} from './to-hexadecimal.js'\nimport {toDecimal} from './to-decimal.js'\nimport {toNamed} from './to-named.js'\n\n/**\n * Encode `character` according to `options`.\n *\n * @param {number} code\n * @param {number} next\n * @param {FormatSmartOptions} options\n * @returns {string}\n */\nexport function formatSmart(code, next, options) {\n  /** @type {string} */\n  var named\n  /** @type {string} */\n  var numeric\n  /** @type {string} */\n  var decimal\n\n  if (options.useNamedReferences || options.useShortestReferences) {\n    named = toNamed(\n      code,\n      next,\n      options.omitOptionalSemicolons,\n      options.attribute\n    )\n  }\n\n  if (options.useShortestReferences || !named) {\n    numeric = toHexadecimal(code, next, options.omitOptionalSemicolons)\n\n    // Use the shortest numeric reference when requested.\n    // A simple algorithm would use decimal for all code points under 100, as\n    // those are shorter than hexadecimal:\n    //\n    // * `&#99;` vs `&#x63;` (decimal shorter)\n    // * `&#100;` vs `&#x64;` (equal)\n    //\n    // However, because we take `next` into consideration when `omit` is used,\n    // And it would be possible that decimals are shorter on bigger values as\n    // well if `next` is hexadecimal but not decimal, we instead compare both.\n    if (options.useShortestReferences) {\n      decimal = toDecimal(code, next, options.omitOptionalSemicolons)\n\n      if (decimal.length < numeric.length) {\n        numeric = decimal\n      }\n    }\n  }\n\n  return named &&\n    (!options.useShortestReferences || named.length < numeric.length)\n    ? named\n    : numeric\n}\n"]},"metadata":{},"sourceType":"module"}